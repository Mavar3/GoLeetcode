### Первая мысль
```ruby
return 0 if s.size < k

if s.size == k
	s.uniq.size == 1 ? return k : return 0 # Если текст весь из одной буквы, то тогда решение - k
end
```
### Втора мысль
#### k = 2
"ababbc" => 5
```
{
	"a" => [0, 2],
	"b" => [1, 3, 4],
	"c" => [5]
}
```
#### k = 2
"ababebc" => 4
```
{
	"a" => [0, 2],
	"b" => [1, 3, 5],
	"e" => [4],
	"c" => [6]
}
```
Везде, где длина массива (l) > k - выпишем.
[0, 2, 1, 3, 5]
Количество ключей - которые мы выписали (count) * k
2 * 2 = 4
=> Должно быть не меньше 4 чисел подряд без перерыва иначе 0
[0, 2, 1, 3]

#### k = 2
"fababebc" => 4
```
{
	"f" => [0],
	"a" => [1, 3],
	"b" => [2, 4, 6],
	"e" => [5],
	"c" => [7]
}
```
Везде, где длина массива (l) > k - выпишем.
[1, 3, 2, 4, 6]
Количество ключей - которые мы выписали (count) * k
2 * 2 = 4
=> Должно быть не меньше 4 чисел подряд без перерыва иначе 0
[1, 3, 2, 4]

### Третья мысль
Разбить на другие слова по разделяемым буквам.
Так, в примере: "fababebc" => 4 разделяемыми буквами будут ['f', 'e', 'c']
=> ['','abab','b']
~~Для каждого из элемента массива провернуть тоже, что и во второй мысле, совмещённой с третьей~~
А вернее, надо найти максимальный по длине элемент массива.

### Действия
1. Разделить массив на хэш-мапу;
2. Поделить массив на слайсы от...
### Опровержение теории выше
#### k = 2
##### Вторая мысль
"fababebce" => 4
```
{
	"f" => [0],
	"a" => [1, 3],
	"b" => [2, 4, 6],
	"e" => [5, 8],
	"c" => [7]
}
```
Везде, где длина массива (l) > k - выпишем.
[1, 3, 2, 4, 5, 6, 8]
~~Количество ключей - которые мы выписали (count) * k
2 * 2 = 4~~
~~=> Должно быть не меньше 4 чисел подряд без перерыва иначе 0
[1, 3, 2, 4]~~
##### Третья мысль
"fababebce" делим на подмассивы ["ababeb", "e"]
Как видим, тоже не работает.

### Ещё попытка
```ruby
return 0 if s.size < k

if s.size == k
	s.uniq.size == 1 ? return k : return 0 # Если текст весь из одной буквы, то тогда решение - k
end

# Если каждый элемент хешмапы больше или равен по длине, чем k => верни длину этого подмассива
```

### Финальный план?
1. Составить Хэшмапу;
2. Поделить на подмассивы (как, по ходу разберёмся);
3. Для каждого элемента массива вызвать функцию longestSubstring (найдя максимум).
